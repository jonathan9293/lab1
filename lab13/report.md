---
# Front matter
Язык: ru-RU
Заголовок: "Отчет по лабораторной работе №13"
Название: "Программирование в командном процессоре OC UNIX. Расщиренное программирование"
Автор: "Салискте Джонатан Д."
Группа: "НКНбд-01-20"
---

## Цель работы

Изучить основы программирования в оболочке ОС UNIX. Научиться писать более сложные командные файлы с использованием логических управляющих конструкций и циклов.

## Ход работы

1. Написали командный файл,реализующий упрощённый механизм семафоров.
   Командный файл дожидается в течение некоторого времени t1 освобождения ресурса, выдавая об этом сообщение, а дождавшись его освобождения, использует его в течение некоторого времени t2<>t1, также выдавая информацию о том, что ресурс используется соответствующим командным файлом (процессом).
2. Реализовали команду man с помощью командного файла.
   Изучили содержимое каталога /usr/share/man/man1.
   В нем находятся архивы текстовых файлов, содержащих справку по большинству установленных в системе программ и команд.
   Каждый архив можно открыть командой less сразу же просмотрев содержимое справки.
   Командный файл получает в виде аргумента командной строки название команды и в виде результата выдавать справку об этой команде или сообщение об отсутствии справки, если соответствующего файла нет в каталоге man1.
3. Используя встроенную переменную $RANDOM, написали командный файл, генерирующий случайную последовательность букв латинского алфавита.

## Вывод

Изучили основы программирования в оболочке OC UNIX/Linux. Научились писать командные файлы.

## Контрольные вопросы

1. $1 следует внести в кавычки.

2. С помощью знака >,| можно объединить несколько строк в одну.

3. Эта утилита выводит последовательность целых чисел с заданным шагом. Также

можно реализовать с помощью утилиты jot.

4. Результатом вычисления выражения $((10/3)) будет число 3.

5. В zsh можно настроить отдельные сочетания клавиш так, как вам нравится. Использование истории команд в zsh ничем особенным не отличается от bash. Zsh очень удобен для повседневной работы и делает добрую половину рутины за вас. Но стоит обратить внимание на различия между этими двумя оболочками. Например, в zsh после for обязательно вставлять пробел, нумерация массивов в zsh начинается с 1, чего совершенно невозможно понять. Так, если вы используете shell для повседневной работы, исключающей написание скриптов, используйте zsh. Если вам часто приходится писать свои скрипты, только bash! Впрочем, можно комбинировать.

6. Синтаксис конструкции for ((a=1; a <= LIMIT; a++)) верен.

7. Язык bash и другие языки программирования:

a. Скорость работы программ на ассемблере может быть более 50% медленнее, чем программ на си/си++, скомпилированных с максимальной оптимизацией;

b. Скорость работы виртуальной ява-машины с байт-кодом часто превосходит скорость аппаратуры с кодами, получаемыми трансляторами с языков высокого уровня. Ява-машина уступает по скорости только ассемблеру и лучшим оптимизирующим трансляторам;

c. Скорость компиляции и исполнения программ на яваскрипт в популярных браузерах лишь в 2-3 раза уступает лучшим трансляторам и превосходит даже некоторые качественные компиляторы, безусловно намного (более чем в 10 раз) обгоняя большинство трансляторов других языков сценариев и подобных им по скорости исполнения программ;

d. Скорость кодов, генерируемых компилятором языка си фирмы Intel, оказалась заметно меньшей, чем компилятора GNU и иногда LLVM;

e. Скорость ассемблерных кодов x86-64 может меньше, чем аналогичных кодов x86, примерно на 10%;

f. Оптимизация кодов лучше работает на процессоре Intel;

g. Скорость исполнения на процессоре Intel была почти всегда выше, за исключением языков лисп, эрланг, аук (gawk, mawk) и бэш. Разница в скорости по бэш скорее всего вызвана разными настройками окружения на тестируемых системах, а не собственно транслятором или железом. Преимущество Intel особенно заметно на 32-разрядных кодах;

h. Стек большинства тестируемых языков, в частности, ява и яваскрипт, поддерживают только очень ограниченное число рекурсивных вызовов. Некоторые трансляторы (gcc, icc, ...)

позволяют увеличить размер стека изменением переменных среды исполнения или параметром;

i. В рассматриваемых версиях gawk, php, perl, bash реализован динамический стек, позволяющий использовать всю память компьютера. Но perl и, особенно, bash используют стек настолько экстенсивно, что 8-16 ГБ не хватает для расчета ack(5,2,3)

## Приложение

![](https://github.com/dsshestakov/Lab_13/blob/main/img/Снимок%20экрана%202021-06-05%20в%2011.10.48.png)
**Рис.1**
![](https://github.com/dsshestakov/Lab_13/blob/main/img/Снимок%20экрана%202021-06-05%20в%2011.12.59.png)
**Рис.2**
![](https://github.com/dsshestakov/Lab_13/blob/main/img/Снимок%20экрана%202021-06-05%20в%2011.13.34.png)
**Рис.3**
![](https://github.com/dsshestakov/Lab_13/blob/main/img/Снимок%20экрана%202021-06-05%20в%2011.21.54.png)
**Рис.4**
